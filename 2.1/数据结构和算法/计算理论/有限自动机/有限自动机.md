# 有限自动机

所谓有限自动机，实际上是对计算机求解问题的过程进行抽象化的一个模型。

有限，指内部状态是有限个的。自动机，指该模型在接受输入后，自动进行状态推算，返回最终结果：接受或拒绝。

上一节提到，一个判定性问题等价于一个字母表上的一个语言。有限自动机就是在这样一个前提下的、由输入符号进行状态转移的模型。

## 确定有限自动机DFA

### （一）示例分析

![确定有限自动机示例](U:\home\lbz\GitHouse\数据结构和算法\计算理论\有限自动机\附加材料\确定有限自动机实例.png)

以上，为一个确定有限自动机的状态图，我们以此来分析。

1.**状态：即图中各个节点。代表了一个外界输入后获得的结果。**

- 接受状态$q_{0}$：当输入结束，最终推算到该状态时,自动机返回接受，可不唯一。
  
- 起始状态$q_{0}$ ：最开始经过的状态节点。
  
2.**转移函数：即图中各个箭头。状态之间的转移，依靠外界的输入来确定方向**。

*注：外界的输入应当为该问题对应语言字母表内的字符*

整个过程，运行开始于**从初始状态开始沿转移箭头进行推算**，结束于**输入读完后看状态处于接收状态就接受，否则就拒绝**。

### （二） 定义

**有限自动机**是一个五元组($Q,\Sigma,\delta,s,F$)

- Q是有限集，称为状态集；
  
- $\Sigma$是有限集，称为字母表
  
- $\delta$：$Q\times\delta$->Q是转移函数
  
- s$\in$Q是初始状态
  
- F$\in$Q是接受状态集
  
**有限自动机处理输入的过程**为

设M($Q,\Sigma,\delta,s,F$)为一个DFA,w为字母表$\Sigma$上的一个字符串并作为输入。

若存在Q中的状态序列$r_{0},r_{1},……,r_{n}$,满足：

- $r_{0}$=s
  
- $r_{i+1}=\delta(r_{i},w_{i+1})$
  
- $r_{n}\in F$
  
则称M接受输入w,记为$\delta(r_{0},w) \in F$

## 非确定有限自动机NFA

### （一）实例分析

![NFA实例](U:\home\lbz\GitHouse\数据结构和算法\计算理论\有限自动机\附加材料\NFA实例.png)

以上，为一个具体的非确定有限自动机NFA的实例。

非确定有限自动机基本脱胎于确定有限自动机，其**区别**在于：

- 每一步可以有多种方式进入下一步。
  
  **当前状态在接收一个输入后，对应不同转移函数，可以跳转到多个下一状态**
  
- 转移函数接受空串ε输入。
  
  **当前状态下不读入任何输入即可跳转到下一状态**
  
一个NFA的计算过程是线性的，类似于**树状的线性展开**，即对可能出现的多个下一状态复制多个副本并同步进行计算，可以理解为NFA对一个具有多个下一状态的输入具有**猜测能力**。

![NFA树状线性计算过程](U:\home\lbz\GitHouse\数据结构和算法\计算理论\有限自动机\附加材料\NFA树状计算过程.png)

**注：应当关注到，无论DFA还是NFA，在某状态下如果遇到无法处理的输入，该分支就会拒绝并停机。**

### （二）NFA形式定义

NFA是一个五元组(Q,Σ,δ,s,F)，其中

- Q是状态集
  
- Σ是字母表
  
- δ: Q× Σε→P(Q)是转移函数；其中Σε = Σ ∪ {ε}**（接受空串输入）**
  
- s∈Q是起始状态
  
- F⊆Q是接受状态集
  
**非确定有限自动机处理输入的过程定义**为：

设N=(Q,Σ,δ,s,F)是一台NFA, w=$w{\tiny 0}w{\tiny 1}w{\tiny 2}…w{\tiny n}$是Σ的一个字符串

若存在Q中的一个状态序列$r{\tiny 0},r{\tiny 1},……,r{\tiny n}$,满足

1. $r{\tiny 0}$=s
   
2. $r{\tiny i+1} \in \delta(r{\tiny i},w{\tiny i+1})$
   
3. $r{\tiny n} \in F$
   
则称该非确定有限自动机N接受字符串w。

### （三）NFA与DFA的关系

***定理：每个NFA都有一台与之等价的DFA。两者的语言相同，即L(NFA)=L(DFA)**

由NFA给出与之等价的DFA的过程，称为NFA的确定化过程。

其基本思想是：由于在NFA中，某个状态在接收某个输入字符后，可能会跳转到的状态不唯一，因此我们将所有可能的结果状态作为一个状态集合，构成等价DFA的一个状态。

其基本方法是：

1. **确定起始状态S'**：将从 NFA 的起始状态S出发经过任意条ε弧（空串输入）所能到达的状态组成的集合作为 DFA 的起始状态S′
   
2. **确定其它状态**：从S′出发，对对字母表内所有输入符号a，考虑当前状态下可能出现的结果状态（包括读入符号a之后再经过空串输入后到达的状态），以上状态所组成的集合作为 DFA 的一个新状态
   
3. **重复以上过程，直至不产生新的 DFA 的状态为止**
   
4. **确定接受状态**：在所产生的 DFA 状态中，含有原 NFA 接受态的状态集作为 DFA 的接受态
   
## 正则语言运算和正则表达式

### （一）正则语言运算和其封闭性

所谓**正则语言**：即存在一个有限自动机，使当前语言为该有限自动机的语言。

***注：判断正则语言时，构造DFA或NFA均可，两者是等价的**

正则语言可以进行以下的运算，称为**正则运算**：

(1)并A∪B = {x | x∈A 或x∈B}

(2)连接 AB = {xy | x∈A, y∈B}

(3)星号A*= {ε}∪A∪AA∪AAA∪…={$x_0x_1……x_k$ |k≥0 且每一个$x_i$∈A}

(4)补A$^{c}$ = {x| x∈Σ*-A}

(5)相对补A-B= A∩~B

(6)对称差A⊕B = (A−B)∪(B−A)

**正则语言对于正则运算是封闭的**，即正则语言经正则运算后得到的语言也为正则语言。

### （二）正则表达式

#### 定义

若R是

1. a,a$\in \Sigma$
   
2. $\varepsilon$(空串)
   
3. $\oslash$（空）
   
4. (R$_1$∪R$_2$), R$_1$和R$_2$是正则表达式
   
5. (R$_1$R$_2$), R$_1$和R$_2$是正则表达式
   
6. （$R'^{*}$）,$R'$是正则表达式
   
则称R是一个正则表达式

#### 等价定理

语言A是正则语言$\Leftrightarrow$语言A可用正则表达式进行描述$\Leftrightarrow$语言A是某个有限自动机的语言

即**正则表达式与DFA和NFA是等价的**

#### 有限自动机和正则表达式的互相转化

1. DFA转化为等价的正则表达式
   
   **基本方法**：通过将DFA改造为等价的***GNFA***~~可以每次读入一个符号段的有限自动机~~
   
   且有以下特殊要求：
   
   （1）起始状态无射入箭头
   
   （2）该自动机只有唯一的接受状态
   
   **基本手段：** 一个一个的去掉中间状态，最后只剩下仅包含起始状态和接受状态的GNFA。
   
   ![DFA转化正则表达式实例](U:\home\lbz\GitHouse\数据结构和算法\计算理论\有限自动机\附加材料\DFA转化GNFA.png)**替换规则**：
   
   ![替换规则](U:\home\lbz\GitHouse\数据结构和算法\计算理论\有限自动机\附加材料\替换规则.png)
   
2. 正则表达式转化为等价的NFA
   
   是上述过程的逆过程，可自行根据正则表达式中语言的结构，进行等价的NFA的构建
   
### （三）正则语言的泵引理

**定理**：设A是正则语言，则 **存在p>0(泵长度)** 使得对于 **任意的w$\in$A且|w|$\ge$p,存在分割w=xyz** 满足：

1. |y|>0
   
2. |xy|$\le$p
   
3. 对任意i$\ge$0,xy$^{i}$z$\in$A
   
**原理**：泵长度p实际为正则语言A的有限自动机的状态数，A中任意字符串w长度大于等于泵长度，根据鸽巢原理，有限自动机在处理该字符串时必定出现循环现象的发生。因此对该循环部分对应的字符进行扩充，其仍然循环，仍然属于该正则语言。

**常用的等价形式**：由于泵引理仅为一必然条件，即正则语言$\Rightarrow$泵引理，因此泵引理无法证明某一语言为正则语言，但其等价形式可以用来证明某一语言为非正则语言。

即对于**任意p$\ge$0(泵长度)**，都**存在w$\in$A且|w|$\ge$p**,使的对于**任意的一个分割w=xyz满足：**

1. |y|>0
   
2. |xy|$\le$p
   
3. 对于任意的i$\ge$0,xy$^{i}$z$\notin$A
   
**实例**：

![泵引理应用实例](U:\home\lbz\GitHouse\数据结构和算法\计算理论\有限自动机\附加材料\泵引理应用实例.png)

