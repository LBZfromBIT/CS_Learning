# 可判定性及可约归性

## （一）算法及其可判定性

接上一部分最后内容，我们讨论了**算法的计算理论定义：每个算法都与一个图灵判定器等价**。

因此，**一个问题可解$\Leftrightarrow$存在算法$\Leftrightarrow$存在一个图灵判定器**。

我们可以依照是否可解对问题进行分类或对问题的可解性进行证明或证伪。每个判定性问题都与{0,1}上的语言一一对应，因此问题的可解性就转化到了构造对该语言的图灵机程序。

## （二）关于正则语言的可判定性

### 1.DFA接受性问题

即检测一个给定的确定型有穷自动机B是否接受某一特定的串w

**问题的形式定义：**

A$_{DFA}$={<B,w>|DFA B接受串w}

DFA B接受串w $\Leftrightarrow$ <B,w>$\in$A$_{DFA}$

- 注意：问题的输入是一个有序对，是一个DFA和一个字符串
  
**定理**：

A$_{DFA}$={<B,w>|DFA B接受串w}是一个可判定语言

**构造方式：**

在图灵机M内,在串w上模拟B的运行:

如果模拟以接受状态结束，则M也接受

如果模拟以拒绝状态结束，则M也拒接

### 2.NFA接受性问题

即检测一个给定的非确定型有穷自动机B是否接受一个给定的串w

**问题的形式定义**：

A$_{NFA}$=={<B,w>|NFA B接受串w}

NFA B接受串w $\Leftrightarrow$ <B,w> $\in$ A$_{NFA}$

**定理：**

A$_{NFA}$={<B,w>|NFA B接受串w}是一个可判定语言

**构造方式**：

在图灵机M内，先构造与NFA B等价的DFA D，并在串w上模拟D的运行：

如果模拟以接受状态结束，则M也接受

如果模拟以拒绝状态结束，则M也拒接

### 3.正则表达式派生问题

即检测一个正则表达式R是否派生一个给定的串w

**问题的形式定义：**

A$_{REX}$={<R,x>|正则表达式R派生串w}

正则表达式R派生串w $\Leftrightarrow$ <R,x> $\in$ A$_{REX}$

**定理：**

A$_{REX}$={<R,w>|正则表达式R派生串w}是一个可判定语言

**构造方式**：

在图灵机M内，先构造与正则表达式R等价的DFA D，并在串w上模拟D的运行：

如果模拟以接受状态结束，则M也接受

如果模拟以拒绝状态结束，则M也拒接

### 4.DFA空性问题

即判断一个DFA是否根本不接受任何串的问题

**问题的形式定义：**

E$_{DFA}$={< A >|A是DFA, L(A)=∅}

DFA A不接受任何串 $\Leftrightarrow$ A $\in$ E$_{DFA}$

**定理：**

E$_{DFA}$= {< A >|A是DFA, L(A)=∅}是一个可判定语言

**构造方法：**

在图灵机M内,对于输入的DFA：

1. 先标记起始状态
   
2. 对任一未标记状态，若有从已标记状态到它的转移，则将它标记
   
3. 检查当前的标记状态，如果为接受状态则拒绝；如果不为接受状态则重复2，直至所有状态都被标记，则接受。
   
### 5.DFA等价性问题

即判断两个DFA是否识别同一个语言

**问题的形式定义：**

EQ$_{DFA}$={<A,B>|A和B是两个DFA且L(A)=L(B)}

**定理：**

EQ$_{DFA}$={<A,B>|A和B是两个DFA且L(A)=L(B)}是一个可判定语言

**构造方法：**

> 两集合相等 $\Leftrightarrow$ 两集合的对称差运算结果为空
> 
利用正则语言对于对称查运算的封闭性，在图灵机M内：

1. 构建新的DFA C,使得L(C)=L(A)⊕L(B)
   
2. 将< C>作为输入在E$_{DFA}$的图灵机上运行
   
3. 如果内部图灵机的结果为接受，则接受；否则拒绝
   
## （三）关于图灵机的可判定性

### 1.图灵机接受问题 A$_{TM}$

即检查一个图灵机是否接受一个给定的串

**问题的形式定义**：

A$_{TM}$={<M, w>|M是一个图灵机，且M接受串w}

**定理：**

A$_{TM}$是可识别但不可判定的

**构造方式**：

在**图灵识别器**D内，模拟在串w上运行图灵机M，如果M接受则接受，如果M拒绝则拒绝。

但无法构建**图灵判定器。**

### 2.图灵机停机问题HALT$_{TM}$

即检查一个图灵机是否在一个特定的串上会停机

**问题的形式定义：**

HALT$_{TM}$={ <M, x> | 图灵机M在串x上会停机 }

**定理**：

HALT$_{TM}$是图灵可识别但不可判定的

**构造方式：**

在**图灵识别器**D内，模拟在串x上运行图灵机M，如果M在x上停机，则接受；否则则拒绝。

但无法构建**图灵判定器**。

### 3.图灵机的空性问题E$_{TM}$

> 前置定理：可归约性
> 
> 如果存在归约映射P $\le _{m}$ Q，使得对于每个p $\in$ P,都有 f(p) $\in$ Q,则称P可以归约到Q
> 
> 此时如果Q成立，则P也成立；
> 
> 如果P不成立，则Q也不成立；
> 
即检查一个图灵机是否根本不接受任何串

**问题的形式定义**：

E$_{TM}$={< M>|M是图灵机, L(M)=∅}

**定理：**

E$_{TM}$是可识别但不可判定的。

**证明**：

利用A$_{TM}$ 可归约到E$_{TM}$，假设E$_{TM}$的判定器存在，能够构建A$_{TM}$的判定器，这与A$_{TM}$不可判定矛盾。

### 4.图灵机的等价性问题EQ$_{TM}$

即检查两个给定的图灵机是否识别相同的语言

**问题的形式定义：**

EQ$_{TM}$= { <M1,M2> | M1和M2是图灵机，且L(M1)=L(M2) }

**定理：**

EQ$_{TM}$是可识别但不可判定的。

**证明：**

利用E$_{TM}$可归约到EQ$_{TM}$,假设EQ$_{TM}$判定器存在，构建一个L(A)=∅的图灵机A,因此利用A和EQ$_{TM}$判定器，E$_{TM}$可判定，矛盾。

### 5.HALT$_{TM}$的补语言$HALT ^c _{TM}$

> 前置定理：
> 
> 语言A的补定义为：$A^c = \Sigma ^* -A$
> 
> 语言A可判定 $\Leftrightarrow$ A和A$^c$都是图灵可识别的
> 
**由于HALT$_{TM}$是不可判定的，因此由定理，停机问题HALTTM的补不是图灵可识别的。**

### 6.LBA接受性问题

> 线性界限自动机:  **L**inear **B**ounded **A**utomata
> 
> 是一类特殊的图灵机，其带头不能移出输入区的常数倍区域
> 
> 其等价于上下文有关语言
> 
> ![语言包含关系](U:\home\lbz\GitHouse\数据结构和算法\计算理论\可计算问题\附加材料\语言包含关系.png)
> 
即检测一个给定的线性界限自动机LBA是否接受一个给定的串

**问题的形式语言**：

A$_{LBA}$={<M, w>| LBA M接受串w}

**定理：**

A$_{LBA}$是图灵可判定的。

**证明：**

由于LBA M的输入区域有限，其格局也为有限个（状态q个，带符号g个，串长n，则器格局最多为qng$^n$个）

因此构建图灵机T：

在串w上模拟运行LBA M,如果M接受则接受，如果M拒绝则拒绝。如果M不停机，则当M运行qng$^n$次后，由于不在产生新的格局，直接停机拒绝。

## （四）各语言类的运算封闭性

![运算封闭性](U:\home\lbz\GitHouse\数据结构和算法\计算理论\可计算问题\附加材料\运算封闭性.png)

